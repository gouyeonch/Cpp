# 2. C++ 함수와 네임 스페이스

***

 ### 디폴트 매개변수

간단한 개념이다

함수를 호출 할 때 값을 넣지 않아도, 선언 시 미리 값을 지정해 놓는 방식의 매개 변수를

디폴트 매개변수라고 한다

즉, 디폴트 값은 <u>함수 원형의 선언 부분</u>에 기술해야 한다



1. 디폴트 값으로 지정 할 매개변수들은 함수 선언 시 오른쪽으로 몰아 놓는다
2. 위에서 기술한 대로 오른쪽으로 몰아 놓고, 물론 중간에 빼먹으면 안된다
3. 호출 할 때는 왼쪽부터 순서대로 기술하되, 디폴트 값을 전제로 중간에 빼먹으면 안된다



주의 할 점으로

호출자의 코드만 보고서는 절대로 함수의 원형을 정확히 알아낼 수 없다

애초에 디폴트 값의 전제가 이것도 맞고 저것도 맞다는 식이기 때문에

식의 모호성을 만들 수 밖에 없다



코드 상에서 사용자와 개발자 간의 유연함을 더할때 유용하게 사용 될 듯 하다

하지만 불필요한 편의를 위해 납용하면 안될듯



### 함수 다중 정의

**다중 정의 일반**

이름이 같은 함수가 다른 작업을 수행하도록 여러개로 다중 정의 할 수 있다

당장 책에 나오는 함수 다중 정의는 호출 받는 매개변수에 맞춰서 정의 된다

이름이 같은 함수가 반환 형식이나 호출 규칙이 다르면 안된다



당연한 얘기지만 모호성을 만든다

함수 호출의 구체적인 대상이 무엇인지 식별해야 한다

많이 쓸지는 잘 모르겠지만, 많이 봤던 거 같기도 하다



**함수 템플릿**

다중 정의의 단점을 잘 보완해 주는 문법이다

같은 일을 여러번 해서 쓸데없이 메모리를 낭비하는 일을 차단한다

같은 일을 하는 코드가 여러 번 등장할 필요가 없어졌기 때문에 안정적인 구조를 만든다

즉, 다중 정의의 모호성을 배제 할 있다

많이 쓰이는 문법인듯

```cpp
template <typename T>
T Add(T a)
{
    return a;
}
```



### 인라인 함수

함수 호출로 인한 오버헤드(대충 메모리 소모)를 줄이고자 메크로를 쓰자니

메크로는 매개변수에 형식을 지정해서, 즉 자료형을 부여해서 연산하는게 불가능 했다

그래서 등장한게 인라인 함수다

함수와 메크로의 단점을 상호 보완해서 합친 문법이다

```cpp
inline int Add(int a, int b)
{
    return a+b;
}
```

쓸 수 있으면 쓰는 게 복잡도 측면에서 유리하다

근데 같은 코드가 기계어에 계속 반복해서 안좋으므로 적당히 짧은 거 아니면 쓰지 말라고 한다

뭔소린지는 모르겠다

컴파일러가 자동으로 정해주기도 한다고 한다



**r- value 참조**

아직 뭔소린지 잘 모르겠다

상수형 참조라고도 하고

연산 <u>임시 결과</u>로 나타나는 상수를 참조 할 수 있다

```cpp
int &&rdata = nInput * 5;
```



### 네임스페이스

소속이나 구역의 개념이다

``` cpp
namespace TEST
{
    int g_nData = 100;
    
    void TestFunc(void)
    {
        cout<<g_nData<<endl;
    }
}
```

``` cpp
TEST::TestFunc();
```

소속을 나누면 규모가 큰 프로그램을 만들기 좋다

보통 개인이 식별자에 붙이는 이름이 코드 내부에서 중복 될 확률이 높기 때문

추가로 모듈화를 함과 동시에 용도를 명시 할 수 있다는 점에서 가시성에 큰 이점이 생긴다



네임스페이스 안에 또 다른 네임스페이스가 속할 수 있다

이를 네임스페이스 중첩이라 부른다



using으로 호출 연산자 ::를 생략 할 수 있지만 모소성이 발생한다

```cpp
using namespace TEST;
```

이 문법 때문에 오류가 발생한다면 결국 네임스페이스를 구체적으로 명시해

모호성을 제거하는 수 밖에 없다



앞에서 설명했던 <u>함수의 다중정의의 이름이 네임스페이스</u>라고 할 수 있다

즉, 이름이 같다는 것은 속해 있는 네임스페이스가 같다는 뜻

그리고 아예 같은 함수 더라도 네임스페이스가 다르면 다르게 인식하고, 사용된다



### 식별자 검색 순서

**전역 함수인 경우**

1. 현재 블록 범위
2. 상위 블록 범위
3. 가장 최근에 선언된 전역 변수나 함수
4. using 선언된 네임스페이스 혹은 전역 네임스페이스 (물론 같은 식별자가 두 개라면 에러)



**클래스 메서드인 경우**

1. 현재 블록 범위
2. 상위 블록 범위
3. 클래스의 멤버
4. 부모 클래스의 멤버
5. 가장 최근에 선언된 전역 변수나 함수
6. 호출자 코드가 속한 네임스페이스의 상위 네임스페이스
7. using 선언된 네임스페이스 혹은 전역 네임스페이스 (물론 같은 식별자가 두 개라면 에러)



아직 클래스에 관한 것은 정확히 모른다



전역 변수는 네임스페이스 보다 선언 순서를 생각해야 된다

대충 절차지향의 성격을 어느 정도는 파악 하라는 말인 듯
